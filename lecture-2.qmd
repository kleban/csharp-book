---
title: Тема 2. Основи алгоритмізації
keywords: алгоритми, блок-схеми, структури алгоритмів, лінійна структура, розгалуження, цикли, DiagramDesigner, draw.io, графічне представлення алгоритмів
description: "Лекція присвячена вивченню основ побудови алгоритмів, їх характеристикам та графічному представленню за допомогою блок-схем. Розглядаються історія виникнення алгоритмів, їх властивості, способи запису та інструменти для створення блок-схем"
author: "Юрій Клебан"
date: "02/02/2025"
date-format: short
---

_У лекції розглядаються матеріали: поняття та характеристики алгоритмів, побудова алгоритмів з використанням блок-схем, ствоерення блок-схем з використанням Diagramm Designer та draw.io. Також розглядаються основні елементи для побудови блок-схем алгоритмів та приклади реалізації._

------------------------------------------------------------------------

## 2.1. Поняття та характеристики алгоритмів

Слово алгоритм походить від імені перського вченого, астронома та математика Аль-Хорезмі. Близько 825 до н. е. він написав трактат, в якому описав придуману в Індії позиційну десяткову систему числення. В першій половині XII століття книжка потрапила до Європи в перекладі латинською мовою під назвою Algoritmi de numero Indorum. Вважається, що перше слово в перекладі відповідає невдалій латинізації імені Аль-Хорезмі, а назва перекладу звучить як «Алгорітмі про індійську лічбу».

Перший алгоритм, призначений для виконання на автоматичному обчислювальному пристрої (комп'ютері), описала Ада Лавлейс в 1843 році. Алгоритм мав обчислювати числа Бернуллі й працювати на аналітичній машині Беббіджа. Цей алгоритм вважається першою комп'ютерною програмою, а його розробниця, Ада Лавлейс — першим програмістом.
<p class="text-center">
![](img\lecture2\334px-Ada_Lovelace_portrait.jpg)
</p>
<p class="text-center"><i>Рис. 2.1. Баронеса Ада Лавлейс, яку вважають першим програмістом. Джерело: Wikipedia"</i></p>

Розглянемо визначення поняття алгоритм.

**Алгоритм** являє собою послідовність розпоряджень виконавцю. Виконавець повинен неухильно виконувати ці розпорядження. Число таких розпоряджень не є обов'язковим: воно може складати кілька тисяч, мільйонів і навіть трильйонів, але воно не може бути нескінченним. І коли виконавець виконає всі розпорядження, задача, для якої був створений алгоритм, буде вирішена.

**Алгоритм** — система правил виконання обчислювального процесу, що обов'язково приводить до розв'язання певного класу задач після скінченного числа операцій. При написанні комп'ютерних програм алгоритм описує логічну послідовність операцій. Для візуального зображення алгоритмів часто використовують блок-схеми.

Кожен алгоритм є списком точно визначених інструкцій для розв'язання задачі. Починаючи з початкового стану, інструкції алгоритму описують процес обчислення, які відбуваються через послідовність станів, які, зрештою, завершуються кінцевим станом. Перехід з одного стану до наступного не обов'язково детермінований — деякі алгоритми містять елементи випадковості.

**Алгоритм** — це опис процесу вирішення того чи іншого завдання. Алгоритмом називається кінцевий набір правил, розташованих у певному логічному порядку, що дозволяє виконавцю вирішувати будь-яку конкретну задачу з деякого класу однотипних задач.

Алгоритми мають ряд важливих властивостей: 

- **Скінченність**. Алгоритм має завжди завершуватись після виконання скінченної кількості кроків. Процедуру, яка має решту характеристик алгоритму, без, можливо, скінченності, називають методом обчислень. 
- **Дискретність**. Процес, що визначається алгоритмом, можна розчленувати (розділити) на окремі елементарні етапи (кроки), кожен з яких називається кроком алгоритмічного процесу чи алгоритму. 
- **Визначеність**. Кожен крок алгоритму має бути точно визначений. Дії, які необхідно здійснити, повинні бути чітко та недвозначно визначені для кожного можливого випадку. 
- **Вхідні дані**. Алгоритм має деяку кількість (можливо, нульову) вхідних даних, тобто, величин, заданих до початку його роботи або значення яких визначають під час роботи алгоритму. 
- **Вихідні дані**. Алгоритм має одне або декілька вихідних даних, тобто, величин, що мають досить визначений зв'язок із вхідними даними. 
- **Ефективність**. Алгоритм вважають ефективним, якщо всі його оператори досить прості для того, аби їх можна було точно виконати за скінченний проміжок часу з допомогою олівця та аркушу паперу.

Виділяють наступні основні способи запису алгоритмів:

-   ***вербальний*** - алгоритм описується на природній мові;
-   ***символьний*** - алгоритм описується за допомогою набору символів;
-   ***графічний*** - алгоритм описується за допомогою набору графічних зображень.

---

Розглянемо приклад розв'язання задачі.

{{< fa circle-question >}} **Задача 1.** Скласти алгоритм ров’язання квадратного рівняння на комп’ютері та записати його вербальним способом (описати словами). 

Нагадаємо, квадратне рівняння має вигляд: ${ax^2 + bx + c = 0}$.

{{< fa circle-check >}} **Етапи розв'язання задачі:**

1.  Вводимо значення $a$, $b$, $c$.

2.  Обчислюємо дискримінант за фрмулою $d = b^2 - 4ac$.

3.  Якщо $d > 0$ обчислити корені $x_1$, $x_2$ за формулою $x=\frac{b ± \sqrt{d}}{2a}$ та вивести їх значення на екран. Інакше, якщо $d = 0$ – обчислити $x_1=-\frac{b}{2a}$ і вивести на екран. Інакше вивести на екран «Коренів немає».

4.  Вийти з програми.

Ця ж задача на мові програмування C# має вигляд (символьний запис):

{{< fa code >}} *Лістинг 2.1. Розв’язання квадратного рівняння.*

```csharp
static void Main(string[] args)
{
    //Оголошуємо змінні
    double a, b, c, d, x1, x2;

    //Вводимо значення змінних з клавіатури
    Console.WriteLine("Введіть a:");
    a = Convert.ToDouble(Console.ReadLine());
    Console.WriteLine("Введіть b:");
    b = Convert.ToDouble(Console.ReadLine());
    Console.WriteLine("Введіть c:");
    c = Convert.ToDouble(Console.ReadLine());

    //Знаходимо дискримінант
    d = b * b - 4 * a * c;

    if (d > 0)
    {
        x1 = (-b + Math.Sqrt(d)) / (2 * a);
        x2 = (-b - Math.Sqrt(d)) / (2 * a);
        Console.WriteLine("x1 = {0}, x2 = {1}", x1, x2);
    }
    else if (d == 0)
    {
        x1 = -b / (2 * a);
        Console.WriteLine("x = {0}", x1);
    }
    else
        Console.WriteLine("Коренів не існує.");
    //Вихід з програми
}
```

---

## 2.2. Побудова алгоритмів з використанням блок-схем

Для зображення алгоритмів використовуватимемо блок-схеми, що формуються з типових блоків:

<p class="text-center">
![](img/lecture2/lecture-2-algorithm-blocks-blocks.svg")
</p>
<p class="text-center"><i>Рис. 2.2. Типові блоки для формування блок-схем алгоритмів."</i></p>

::: callout-note
Усі блок-схеми створено у *draw.io*.<br> Файли можна знайти [у github репозиторії курсу](https://github.com/kleban/csharp-basics-public/blob/master/diagrams). 
::: 

У теорії алгоритмів доведено, що будь-який, скільки завгодно складний алгоритм може бути складений з трьох основних алгоритмічних структур: лінійної, розгалуження і циклу, показаних, відповідно на `рис. 2.3`.

<p class="text-center">
![](img/lecture2/lecture-2-algorithm-blocks-structures.svg")
</p>
<p class="text-center"><i>Рис. 2.3. Основні алгоритмічні структури</i></p>

Лінійна структура передбачає послідовне виконання дій, без їх повторення або пропуску деяких дій. Зазвичай програмісти прагнуть до того, аби алгоритм мав лінійну структуру.

Структура "розгалуження" передбачає виконання однієї з двох груп дій залежно від виконання умови у блоці розгалуження. На рис. 3 знаком "+" показано виконання умови, а знаком "-" - його невиконання. Часто використовується неповна команда розгалуження, коли один з блоків дії відсутній.

Структура "цикл" має декілька різновидів. На рис. 3 показаний цикл типу "доки" (`while`) з передумовою. Дії всередині цього циклу повторюються доки виконується умова у блоці розгалуження, причому спочатку перевіряється умова, а потім виконується дія. Досить часто використовуються інші типи циклу, показані на `рис. 2.4`.

<p class="text-center">
![](img/lecture2/lecture-2-algorithm-blocks-loops.svg")
</p>
<p class="text-center"><i>Рис. 2.4. Зображення циклів за допомогою блок-схем</i></p>

У циклі з після умовою перевірка умови виходу з циклу виконується після чергової дії. Цикл "для (`for`)" є модифікацією циклу "доки (`while`)" для ситуації, коли заздалегідь відома кількість повторень деяких дій. Запис у блоці заголовка циклу на рис.3 показує приклад опису заголовка циклу, в якому дії повторюються стільки раз, скільки цілих значень набуває параметра циклу i від свого початкового значення 1 до кінцевого N з кроком 1. Зазвичай крок не вказується, якщо він дорівнює 1.

Тепер запишемо алгоритм розв’язання задачі 1 у графічному вигляді.

<p class="text-center">
![](img/lecture2/lecture-2-tasks-task1.svg")
</p>
<p class="text-center"><i>Рис. 2.5. Блок-схема алгоритму знаходження коренів квадратного рівняння до задачі №1</i></p>

Для закріплення знань по лінійних структурах та розгалуженнях побудуємо графічне відображення алгоритмів для кількох задач.

------------------------------------------------------------------------

{{< fa circle-question >}}  **Задача 2.** Побудувати блок-схему алгоритму перевірки введеного числа на невід’ємність.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">
![](img/lecture2/lecture-2-tasks-task2.svg")
</p>
<p class="text-center"><i>Рис. 2.6. Блок-схема алгоритму знаходження коренів квадратного рівняння до задачі №2</i></p>

------------------------------------------------------------------------

{{< fa circle-question >}}  **Задача 3.** Побудувати блок-схему алгоритму зходження периметра та площі трикутника за формулою Герона.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">
![](img/lecture2/lecture-2-tasks-task3.svg")
</p>
<p class="text-center"><i>Рис. 2.7. Блок-схема алгоритму до задачі №3</i></p>

------------------------------------------------------------------------

{{< fa circle-question >}} **Задача 4.** Побудувати блок-схему алгоритму порівняння двох чисел.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">
![](img/lecture2/lecture-2-tasks-task4.svg")
</p>
<p class="text-center"><i>Рис. 2.8. Блок-схема до задачі №4</i></p>

---

Для закріплення знань по циклічних структурах побудуємо графічне відображення алгоритмів для кількох задач.

{{< fa circle-question >}} **Задача 5.** Побудувати блок-схему алгоритму знаходження суми елементів у масиву.

{{< fa circle-info >}} Введемо позначення: $n$ – кількість елементів масиву, $sum$ – змінна, що визначає суму, $x_i$ – $і$-й елемент масиву.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">
![](img/lecture2/lecture-2-tasks-task5.svg")
</p>
<p class="text-center"><i>Рис. 2.9. Блок-схема до задачі №5</i></p>

---

{{< fa circle-question >}}  **Задача 6.** Побудувати блок-схему алгоритму знаходження середнього значення елементів масиву.

{{< fa circle-info >}} Ця задача відрізнється від попередньої лише появою нової змінної $avg$ – середнє значення.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">
![](img/lecture2/lecture-2-tasks-task6.svg")
</p>
<p class="text-center"><i>Рис. 2.10. Блок-схема до задачі №6</i></p>

---

{{< fa circle-question >}}  **Задача 7.** Побудувати блок-схему алгоритму знаходження максимального елемента у масиві.

{{< fa circle-info >}} Введемо позначення: $max$ – максимальний елемент, $n$ - кількість елементів у масиві, $x_i$ – $і$-й елемент масиву. Припускаємо що масив уже заповнений і наперед відомо кількість елементів у масиві.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">
![](img/lecture2/lecture-2-tasks-task7.svg")
</p>
<p class="text-center"><i>Рис. 2.11. Блок-схема до задачі №7</i></p>

---

