---
title: Тема 3. Основи алгоритмізації
keywords: алгоритми, блок-схеми, структури алгоритмів, лінійна структура, розгалуження, цикли, DiagramDesigner, draw.io, графічне представлення алгоритмів
description: "Лекція присвячена вивченню основ побудови алгоритмів, їх характеристикам та графічному представленню за допомогою блок-схем. Розглядаються історія виникнення алгоритмів, їх властивості, способи запису та інструменти для створення блок-схем"
author: "Юрій Клебан"
date: "02/02/2025"
date-format: short
---

*У лекції розглядаються матеріали: поняття та характеристики алгоритмів, побудова алгоритмів з використанням блок-схем, ствоерення блок-схем з використанням Diagramm Designer та draw.io. Також розглядаються основні елементи для побудови блок-схем алгоритмів та приклади реалізації.*

------------------------------------------------------------------------

## 3.1. Поняття та характеристики алгоритмів

Слово алгоритм походить від імені перського вченого, астронома та математика Аль-Хорезмі. Близько 825 до н. е. він написав трактат, в якому описав придуману в Індії позиційну десяткову систему числення. В першій половині XII століття книжка потрапила до Європи в перекладі латинською мовою під назвою Algoritmi de numero Indorum. Вважається, що перше слово в перекладі відповідає невдалій латинізації імені Аль-Хорезмі, а назва перекладу звучить як «Алгорітмі про індійську лічбу».

Перший алгоритм, призначений для виконання на автоматичному обчислювальному пристрої (комп'ютері), описала Ада Лавлейс в 1843 році. Алгоритм мав обчислювати числа Бернуллі й працювати на аналітичній машині Беббіджа. Цей алгоритм вважається першою комп'ютерною програмою, а його розробниця, Ада Лавлейс — першим програмістом.

<p class="text-center">

![](img\lecture2\334px-Ada_Lovelace_portrait.jpg)

</p>

<p class="text-center">

<i>Рис. 3.1. Баронеса Ада Лавлейс, яку вважають першим програмістом. Джерело: Wikipedia"</i>

</p>

Розглянемо визначення поняття алгоритм.

**Алгоритм** являє собою послідовність розпоряджень виконавцю. Виконавець повинен неухильно виконувати ці розпорядження. Число таких розпоряджень не є обов'язковим: воно може складати кілька тисяч, мільйонів і навіть трильйонів, але воно не може бути нескінченним. І коли виконавець виконає всі розпорядження, задача, для якої був створений алгоритм, буде вирішена.

**Алгоритм** — система правил виконання обчислювального процесу, що обов'язково приводить до розв'язання певного класу задач після скінченного числа операцій. При написанні комп'ютерних програм алгоритм описує логічну послідовність операцій. Для візуального зображення алгоритмів часто використовують блок-схеми.

Кожен алгоритм є списком точно визначених інструкцій для розв'язання задачі. Починаючи з початкового стану, інструкції алгоритму описують процес обчислення, які відбуваються через послідовність станів, які, зрештою, завершуються кінцевим станом. Перехід з одного стану до наступного не обов'язково детермінований — деякі алгоритми містять елементи випадковості.

**Алгоритм** — це опис процесу вирішення того чи іншого завдання. Алгоритмом називається кінцевий набір правил, розташованих у певному логічному порядку, що дозволяє виконавцю вирішувати будь-яку конкретну задачу з деякого класу однотипних задач.

Алгоритми мають ряд важливих властивостей:

-   **Скінченність**. Алгоритм має завжди завершуватись після виконання скінченної кількості кроків. Процедуру, яка має решту характеристик алгоритму, без, можливо, скінченності, називають методом обчислень.
-   **Дискретність**. Процес, що визначається алгоритмом, можна розчленувати (розділити) на окремі елементарні етапи (кроки), кожен з яких називається кроком алгоритмічного процесу чи алгоритму.
-   **Визначеність**. Кожен крок алгоритму має бути точно визначений. Дії, які необхідно здійснити, повинні бути чітко та недвозначно визначені для кожного можливого випадку.
-   **Вхідні дані**. Алгоритм має деяку кількість (можливо, нульову) вхідних даних, тобто, величин, заданих до початку його роботи або значення яких визначають під час роботи алгоритму.
-   **Вихідні дані**. Алгоритм має одне або декілька вихідних даних, тобто, величин, що мають досить визначений зв'язок із вхідними даними.
-   **Ефективність**. Алгоритм вважають ефективним, якщо всі його оператори досить прості для того, аби їх можна було точно виконати за скінченний проміжок часу з допомогою олівця та аркушу паперу.

Виділяють наступні основні способи запису алгоритмів:

-   ***вербальний*** - алгоритм описується на природній мові;
-   ***символьний*** - алгоритм описується за допомогою набору символів;
-   ***графічний*** - алгоритм описується за допомогою набору графічних зображень.

------------------------------------------------------------------------

Розглянемо приклад розв'язання задачі.

{{< fa circle-question >}} **Задача 1.** Скласти алгоритм ров’язання квадратного рівняння на комп’ютері та записати його вербальним способом (описати словами).

Нагадаємо, квадратне рівняння має вигляд: ${ax^2 + bx + c = 0}$.

{{< fa circle-check >}} **Етапи розв'язання задачі:**

1.  Вводимо значення $a$, $b$, $c$.

2.  Обчислюємо дискримінант за фрмулою $d = b^2 - 4ac$.

3.  Якщо $d > 0$ обчислити корені $x_1$, $x_2$ за формулою $x=\frac{b ± \sqrt{d}}{2a}$ та вивести їх значення на екран. Інакше, якщо $d = 0$ – обчислити $x_1=-\frac{b}{2a}$ і вивести на екран. Інакше вивести на екран «Коренів немає».

4.  Вийти з програми.

Ця ж задача на мові програмування C# має вигляд (символьний запис):

{{< fa code >}} *Лістинг 2.1. Розв’язання квадратного рівняння.*

``` csharp
static void Main(string[] args)
{
    //Оголошуємо змінні
    double a, b, c, d, x1, x2;

    //Вводимо значення змінних з клавіатури
    Console.WriteLine("Введіть a:");
    a = Convert.ToDouble(Console.ReadLine());
    Console.WriteLine("Введіть b:");
    b = Convert.ToDouble(Console.ReadLine());
    Console.WriteLine("Введіть c:");
    c = Convert.ToDouble(Console.ReadLine());

    //Знаходимо дискримінант
    d = b * b - 4 * a * c;

    if (d > 0)
    {
        x1 = (-b + Math.Sqrt(d)) / (2 * a);
        x2 = (-b - Math.Sqrt(d)) / (2 * a);
        Console.WriteLine("x1 = {0}, x2 = {1}", x1, x2);
    }
    else if (d == 0)
    {
        x1 = -b / (2 * a);
        Console.WriteLine("x = {0}", x1);
    }
    else
        Console.WriteLine("Коренів не існує.");
    //Вихід з програми
}
```

------------------------------------------------------------------------

## 3.2. Побудова алгоритмів з використанням блок-схем

Для зображення алгоритмів використовуватимемо блок-схеми, що формуються з типових блоків:

<p class="text-center">

![](img/lecture2/lecture-2-algorithm-blocks-blocks.svg)

</p>

<p class="text-center">

<i>Рис. 3.2. Типові блоки для формування блок-схем алгоритмів."</i>

</p>

::: callout-note
Усі блок-схеми створено у *draw.io*.<br> Файли можна знайти [у github репозиторії курсу](https://github.com/kleban/csharp-basics-public/blob/master/diagrams).
:::

У теорії алгоритмів доведено, що будь-який, скільки завгодно складний алгоритм може бути складений з трьох основних алгоритмічних структур: лінійної, розгалуження і циклу, показаних, відповідно на `Рис. 3.3`.

<p class="text-center">

![](img/lecture2/lecture-2-algorithm-blocks-structures.svg)

</p>

<p class="text-center">

<i>Рис. 3.3. Основні алгоритмічні структури</i>

</p>

Лінійна структура передбачає послідовне виконання дій, без їх повторення або пропуску деяких дій. Зазвичай програмісти прагнуть до того, аби алгоритм мав лінійну структуру.

Структура "розгалуження" передбачає виконання однієї з двох груп дій залежно від виконання умови у блоці розгалуження. На рис. 3 знаком "+" показано виконання умови, а знаком "-" - його невиконання. Часто використовується неповна команда розгалуження, коли один з блоків дії відсутній.

Структура "цикл" має декілька різновидів. На рис. 3 показаний цикл типу "доки" (`while`) з передумовою. Дії всередині цього циклу повторюються доки виконується умова у блоці розгалуження, причому спочатку перевіряється умова, а потім виконується дія. Досить часто використовуються інші типи циклу, показані на `Рис. 3.4`.

<p class="text-center">

![](img/lecture2/lecture-2-algorithm-blocks-loops.svg)

</p>

<p class="text-center">

<i>Рис. 3.4. Зображення циклів за допомогою блок-схем</i>

</p>

У циклі з після умовою перевірка умови виходу з циклу виконується після чергової дії. Цикл "для (`for`)" є модифікацією циклу "доки (`while`)" для ситуації, коли заздалегідь відома кількість повторень деяких дій. Запис у блоці заголовка циклу на рис.3 показує приклад опису заголовка циклу, в якому дії повторюються стільки раз, скільки цілих значень набуває параметра циклу i від свого початкового значення 1 до кінцевого N з кроком 1. Зазвичай крок не вказується, якщо він дорівнює 1.

Тепер запишемо алгоритм розв’язання задачі 1 у графічному вигляді.

<p class="text-center">

![](img/lecture2/lecture-2-tasks-task1.svg)

</p>

<p class="text-center">

<i>Рис. 3.5. Блок-схема алгоритму знаходження коренів квадратного рівняння до задачі №1</i>

</p>

Для закріплення знань по лінійних структурах та розгалуженнях побудуємо графічне відображення алгоритмів для кількох задач.

------------------------------------------------------------------------

{{< fa circle-question >}} **Задача 2.** Побудувати блок-схему алгоритму перевірки введеного числа на невід’ємність.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">

![](img/lecture2/lecture-2-tasks-task2.svg)

</p>

<p class="text-center">

<i>Рис. 3.6. Блок-схема алгоритму знаходження коренів квадратного рівняння до задачі №2</i>

</p>

------------------------------------------------------------------------

{{< fa circle-question >}} **Задача 3.** Побудувати блок-схему алгоритму зходження периметра та площі трикутника за формулою Герона.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">

![](img/lecture2/lecture-2-tasks-task3.svg)

</p>

<p class="text-center">

<i>Рис. 3.7. Блок-схема алгоритму до задачі №3</i>

</p>

------------------------------------------------------------------------

{{< fa circle-question >}} **Задача 4.** Побудувати блок-схему алгоритму порівняння двох чисел.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">

![](img/lecture2/lecture-2-tasks-task4.svg)

</p>

<p class="text-center">

<i>Рис. 3.8. Блок-схема до задачі №4</i>

</p>

------------------------------------------------------------------------

Для закріплення знань по циклічних структурах побудуємо графічне відображення алгоритмів для кількох задач.

{{< fa circle-question >}} **Задача 5.** Побудувати блок-схему алгоритму знаходження суми елементів у масиву.

{{< fa circle-info >}} Введемо позначення: $n$ – кількість елементів масиву, $sum$ – змінна, що визначає суму, $x_i$ – $і$-й елемент масиву.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">

![](img/lecture2/lecture-2-tasks-task5.svg)

</p>

<p class="text-center">

<i>Рис. 3.9. Блок-схема до задачі №5</i>

</p>

------------------------------------------------------------------------

{{< fa circle-question >}} **Задача 6.** Побудувати блок-схему алгоритму знаходження середнього значення елементів масиву.

{{< fa circle-info >}} Ця задача відрізнється від попередньої лише появою нової змінної $avg$ – середнє значення.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">

![](img/lecture2/lecture-2-tasks-task6.svg)

</p>

<p class="text-center">

<i>Рис. 3.10. Блок-схема до задачі №6</i>

</p>

------------------------------------------------------------------------

{{< fa circle-question >}} **Задача 7.** Побудувати блок-схему алгоритму знаходження максимального елемента у масиві.

{{< fa circle-info >}} Введемо позначення: $max$ – максимальний елемент, $n$ - кількість елементів у масиві, $x_i$ – $і$-й елемент масиву. Припускаємо що масив уже заповнений і наперед відомо кількість елементів у масиві.

{{< fa circle-check >}} **Розвязання задачі графічним способом:**

<p class="text-center">

![](img/lecture2/lecture-2-tasks-task7.svg)

</p>

<p class="text-center">

<i>Рис. 3.11. Блок-схема до задачі №7</i>

</p>

------------------------------------------------------------------------

## 2.3. Ствоерення блок-схем з використанням Diagramm Designer {#chapter23}

**Diagramm Designer** - програмне забезпечення для побудови блок-схем, UML-діаграм, та інших зображень на основі векторної графіки. [{{< fa download >}} Завантажити актуальну версію DiagramDesigner можна тут](https://logicnet.dk/DiagramDesigner/).

Перелік базових функцій Diagramm Designer:

-   Налаштовувана палітра шаблонів.
-   Перевірка правопису.
-   Імпорт / експорт зображень `WMF`, `EMF`, `BMP`, `JPEG`, `PNG`, `MNG`, `ICO`, `GIF` та `PCX`.
-   Переглядач слайд-шоу.
-   Зручний графічний редактор для відображення математичних виразів.
-   Калькулятор для розв'язання рівнянь.
-   Інтеграція з `MeeSoft Image Analyzer` для редагування растрових зображень.
-   Мінімізація розміру файлів.

Розглянемо графічний інтерфейс продукту:

<p class="text-center">

![](img/lecture2/diagramm_designer_1.png)

</p>

<p class="text-center">

<i>Рис. 3.12. Головне вікно програми Diagramm Designer 1.23</i>

</p>

Для створення діаграм використовуєть технологія `Drag&Drop`, тобто елементи можна перетягувати на робочу область. Приклад створення діаграми можна переглянути на відео (у онлайн версії лекції).

Документ `DiagrammDesigner` може мати кілька сторінок, переключення між сторінками за допомогою меню `Diagram` - `Rearrange pages` (Рис. 3.13).

<p class="text-center">

![](img/lecture2/diagramm_designer_2.png)

</p>

<p class="text-center">

<i>Рис. 3.13. Вибір сторінки у програмі Diagramm Designer</i>

</p>

Для форматування тексту у межах графічних блоків (фігур) використовують наступні теги:

<p class="text-center">

![](img/lecture2/diagramm_designer_3.png)

</p>

<p class="text-center">

<i>Рис. 3.14. Редагування тексту у блоці Diagramm Designer</i>

</p>

<center class="simple-table">

*Таблиця 3.1. Теги для форматування тексту у графічних блоках DiagrammDesigner*

| Код        | Стиль                     |
|------------|---------------------------|
| `\B…\b`    | Напівжирний               |
| `\U…\u`    | Підкреслений              |
| `\I…\i`    | Курсив                    |
| `\O…\o`    | Закреслений               |
| `\\`       | \\                        |
| `\H…\h`    | Припіднятий до верху      |
| `\S…\s`    | Символьний шрифт          |
| `\p`       | Номер сторінки            |
| `\L…\l`    | Опущений до низу          |
| `\C######` | Колір у HTML              |
| `\P`       | Загловок сторінки         |
| `\c`       | Кількість сторінок        |
| `\_`       | Горизонтальний розділювач |
| `\n`       | Новий рядок               |
| `\N`       | Підказка                  |

*Таблиця 3.2. Приклади форматування тексту у графічних блоках DiagrammDesigner*

| Код з тегами                 | Текст                          |
|------------------------------|--------------------------------|
| `\B\ID=b\H2\h-4ac`           | $D=b^2-4ac$                    |
| Вводимо значення `\Ba, b, c` | Вводимо значення $a$, $b$, $c$ |
| `\ID > 0`                    | $D > 0$                        |
| Вводимо `\B\Ix\Li\i`         | Вводимо $x_i$                  |

</center>

З іншими можливостями програмного подукту Diagramm Designer можна ознайомитися використовуючи вбудовану довідку програми.

::: callout-warning
Підтримка даного розділу лекції у майбутньому не планується і його варто використовувати швидше для ознайомлення та розширення кругозору слухачів курсу. Рекомендую використовувати `draw.io`.
:::

------------------------------------------------------------------------

## 3.4. Створення блок-схем з використанням draw.io

Варто звернути увагу, що усі діаграми для лекцій створені саме у `draw.io` і можете завантажити їх у [публічному репозиторії курсу на github](https://github.com/kleban/csharp-basics-public/blob/master/diagrams/).

На даний момент проект є безкоштовним і розміщується за адресою <http://diagrams.net/>.

Досить зручною функцією є інтеграція сервісами для зберігання файлів діаграм:

-   {{< fa brands google >}} Google Drive.
-   {{< fa cloud >}} OneDrive.
-   {{< fa brands dropbox >}} Dropbox.
-   {{< fa brands github >}} GitHub.
-   {{< fa brands gitlab >}} GitLab.

<p class="text-center">

![](img/lecture2/draw_io_1.png)

</p>

<p class="text-center">

<i>Рис. 3.15. Вибір джерела для збереження draw.io</i>

</p>

Графічний інтерфейс `draw.io` є досить зручним у користуванні і дозволяє доповнити перелік доступних зображень, блоків, логотипів продуктів для створення схем будь-якого рівня складності.

<p class="text-center">

![](img/lecture2/draw_io_2.png)

</p>

<p class="text-center">

<i>Рис. 3.16. UI головного вікна програми draw.io для Windows</i>

</p>

Досить зручною є функція збереження діаграм для публікації у веб або на паперових носіях формати файлів (png, jpeg, svg, pdf, html, xml), а також вбудовування їх у різні типи документів, що надають сервіси `Google` та `Microsoft`.

Для початку ознайомлення з сервісом `draw.io` рекомендую переглянути коротке відео:

{{< video https://www.youtube.com/watch?v=Z0D96ZikMkc >}}

*Джерело: [youtube канал draw.io](https://www.youtube.com/channel/UCiTtRN9b8P4CoSfpkfgEJHA)*

------------------------------------------------------------------------

## Контрольні запитання

1.  Що таке алгоритм і які його основні властивості?
2.  Назвіть способи запису алгоритмів.
3.  Які основні структури алгоритмів ви знаєте?
4.  Чим відрізняються цикли "while" та "for"?
5.  Як визначити дискретність алгоритму?
6.  Що таке вхідні та вихідні дані алгоритму?
7.  Які графічні елементи використовуються для побудови блок-схем?
8.  Як перевірити ефективність алгоритму?
9.  Які програми можна використовувати для створення блок-схем?
10. Як визначити скінченність алгоритму?

------------------------------------------------------------------------

## Задачі

**Задача 1: Перевірка числа на парність.** Побудувати блок-схему алгоритму, який визначає, чи є введене число парним або непарним.

**Задача 2: Знаходження найменшого елемента в масиві**. Створити блок-схему алгоритму для пошуку найменшого елемента в масиві з N елементів.

**Задача 3: Обчислення факторіалу**. Розробити блок-схему алгоритму обчислення факторіалу введеного натурального числа.

**Задача 4: Перевірка простого числа**. Побудувати блок-схему алгоритму для визначення, чи є введене число простим.

**Задача 5: Конвертація температури**. Створити блок-схему алгоритму перетворення температури з градусів Цельсія в градуси Фаренгейта.

------------------------------------------------------------------------

## Список використаних джерел

1.  Ada Lovelace on Wikipedia. Url: https://en.wikipedia.org/wiki/Ada_Lovelace
2.  DiagramDesigner. Url: https://logicnet.dk/DiagramDesigner/
3.  Draw.IO. Url: https://www.diagrams.net/
4.  Albahari, J., & Albahari, B. (2012). C# 5.0 in a Nutshell, Fifth Edition. 1005 Gravenstein Highway North, Sebastopol, USA: O’Reilly Media, Inc.
5.  Cardelli, L., & Wegner, P. (December 1985 p.). On Understanding Types, Data Abstraction, and Polymorphism. ACM Computing 1. Surveys, 17(4), сс. 149-154. Отримано з http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf
6.  Kort, W. d. (2013). Exam Ref 70-483: Programming in C#. Sebastopol, California 95472: O’Reilly Media, Inc.
7.  MSDN. (без дати). Отримано з Microsoft Developer Network: http://msdn.microsoft.com/

------------------------------------------------------------------------

::: callout-warning
Дорогі друзі, якщо Ви помітили, що для написання матеріалів використані джерела, які я не вказав - прошу надіслати мені інформацію на пошту. Дякую.
:::